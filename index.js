
var fs = require('fs')
const https = require('https')
const TSV = require('tsv')

module.exports = class TsvI18njs {
  constructor(src, encoding, format) {
    this._src = src
    this._encoding = encoding || 'utf-8'
    this._format = format || 'es'
    this._errors = 0
  }

  fetch(url) {
    return new Promise( (resolve, reject) => {
      https.get(url, (res) => {
        let body = ''
        res.setEncoding(this._encoding)
        res.on('data', chunk => body += chunk.replace(/\r/g, ''))
        res.on('end', _ => resolve(body))
      }).on('error', reject)
    })
  }

  read(src) {
    if (src.match(/^https:\/\//)) {
      return this.fetch(src)
    } else {
      return new Promise( (resolve, reject) => {
        return resolve(fs.readSync(src, {encoding: this._encoding}))
      })
    }
  }

  convert(path) {
    return this.read(this._src).then( (tsvString) => {
      const header = tsvString.split('\n')[0].split('\t')
      if (!header.find( k => k === 'key')) {
        this.error('requires "key" column')
        return new Error('requires "key" column')
      }
      const languages = header.filter( k => k !== 'key')
      const tsv = TSV.parse(tsvString)
      return this.buildTranslations(tsv, languages)
    }).then( (translations) => {
      for (let lang in translations) {
        this.generateFile(lang, translations[lang], path)
      }
      return this._errors
    }).catch( this.error.bind(this) )
  }

  tsvStringToTsv(tsvString) {
  }

  generateFile(lang, translation, path) {
    const filePath  = `${path}/${lang}.js`

    const prefix = this._format === 'es' ? 'export default' : 'module.exports ='

    const message = `// THIS FILE IS GENERATED BY tsv-i18njs
// DO NOT MODIFY DIRECTLY.
${prefix} ${ JSON.stringify(translation, null, '  ') }
`
    fs.writeFileSync(filePath, message)
  }

  buildTranslations(tsv, languages) {
    let translations = {}
    for (let lang of languages) {
      translations[lang] = {}
    }

    for (let row of tsv) {
      for (let lang of languages) {
        const value = row[lang]
        const key = row.key.trim()
        if (key.match(/^#/) || key === '') {
          continue
        }
        if (key.match(/\s/)) {
          this.error('i18n key cannot contain any space', key)
          continue
        }

        const pathComponents = key.split('.')
        const lastKey = pathComponents.pop()
        if (lastKey) {
          let obj = this.getObjectForPath(translations[lang], pathComponents)
          if (value) {
            obj[lastKey] = value
          } else {
            this.error(`i18n text not defined ${lang}.${key}`)
          }
        } else {
          this.error('invalid i18n key', key)
        }
      }
    }
    return translations
  }

  getObjectForPath(obj, pathComponents) {
    return pathComponents.reduce( (obj, key) => {
      if (!obj[key]) {
        obj[key] = {}
      }
      return obj[key]
    }, obj)
  }

  error(...args) {
    console.error(...args)
    this._errors++
  }
}
